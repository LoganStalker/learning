# -*- coding:utf-8 -*-

def input_key_and_message(): # процедура ввода ключа и сообщения
    message = input('Введите сообщение: ')
    if len(message) % 2 != 0:   # проверяем длину сообщения, так как сообщение будет при шифровании разбиваться на биграммы, необходимо чтобы в сообщении было четное количество символов.
        message += 'ь'          # в сообщении легко будет понять где лишний символ, если там будет мягкий знак
    message = message.lower()   # переводим сообщение в нижний регистр

    key = tuple(input('Введите ключ: '))    # input получает сообщение (в данном случае это ключ), tuple разбивает ключ на символы и возвращает кортеж
    message = tuple(message)                # разбиваем сообщение на символы

    return key, message # передаем результат

def make_table(key, alfavit):   # создаем таблицу шифрования
    key += alfavit  # объединяем ключ и алфавит в один

    alfavit = []
    for i in key:
        if i not in alfavit:
            alfavit.append(i) # формируем новый алфавит, в котором отбрасываем повторяющиеся символы

    table = []  # будущая таблица
    a = []  # список а - в данном случае это строка таблицы table
    for i in alfavit: # В данном цикле формируем таблицу шифрования
        a.append(i) # добавляем символы в список а
        if (alfavit.index(i)+1) % 8 == 0:   # когда длина списка а становится равной 6
            table.append(a)                 # добавляем список в таблицу
            a = []                          # а потом обнуляем этот список
        if alfavit.index(i) == len(alfavit)-1:
            table.append(a)

    for i in table: # выводим строки таблицы
        print(i)

    return table    # передаем таблицу

def find_index(simbol, table):  # в данной процедуре определяем индекс символа
    for table_row in table: # в цикле перебираем строки таблицы
        col = 0 # это номер столбца
        row = 0 # это номер строки
        if simbol in table_row: # если искомый символ в данной строке,
            col = table_row.index(simbol)   # то определяем номер искомого символа в данной строке
            row = table.index(table_row)         # потом определяем номер данной строки в таблице
            break   # прекращаем выполнение цикла
    return col, row # передаем результаты

def decrypt(table, message):    # процедура расшифрования
    rez = []
    for i in range(1, len(message), 2): # в цикле перебираем каждый второй индекс начиная с 1
        b = message[i]  # берем из сообщения i-й символ
        a = message[i-1]    # берем из сообщения (i-1)-й символ
        acol, arow = find_index(a, table)   # определяем индексы столбца и строки в которых расположен символ A
        bcol, brow = find_index(b, table)   # определяем индексы столбца и строки в которых расположен символ B
        if acol == bcol:    # если символы в одном столбце, то по правилу дешифрования нужно взять символы из строки расположенной выше
            ccol, crow = acol, arow-1   # задаем индексы символа C на основе индексов символа A, от индекса строки при этом отнимаем один, для сдвига на верхнюю строку
            dcol, drow = bcol, brow-1   # аналогично задаем индексы символа D
        elif arow == brow: # если символы располжены в одной строке, то по правилу дешифрования, нужно взять символы из столбцов расположенных слева от исходных
            ccol, crow = acol-1, arow   # задаем индексы символа C, на основе индексов символа A, при этом от индекса столбца отнимаем 1, для сдвига влево
            dcol, drow = bcol-1, brow   # аналогично задаем индексы символа D
        else:   # если ни одно условие из предыдущих не выполнится, то
            ccol, crow = bcol, arow # на подставив соответствующие индексы из индексов символов A и B получим индексы символов
            dcol, drow = acol, brow # расположенных в противоположных углах прямоугольника дешифровки (читайте о шифре Плейфера)

        c = table[crow][ccol]   # из таблицы дешифрования извлекаем символы по полученным координатам
        d = table[drow][dcol]

        rez.append(c)   # добавляем символы в результирующий список
        rez.append(d)

    return rez # возвращаем результат выполнения процедуры

def main(): # главная функция
    print('Шифр Плейфера')

    alfavit = ("а","б","в","г","д","е","ж","з","и","к","л","м","н","о","п","р",
           "с","т","у","ф","х","ц","ч","ш","щ","ъ","ы","ь","э","ю","я","_")
    #alfavit = ("а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р",
    #       "с","т","у","ф","х","ц","ч","ш","щ","ъ","ы","ь","э","ю","я"," ",",",".")

    # с помощью созданных выше процедур и функций задаем сообщение с ключем, обрабатываем и шифруем
    key, message = input_key_and_message()
    table = make_table(key, alfavit)
    rez = decrypt(table, message)

    print(message) # выводим сообщение списком
    print(rez)      # выводим результат списком

    # ниже склеиваем символы из списка rez в одну строку и получаем зашифрованное сообщение
    message = ''
    for i in rez:
        message += i
    print(message)

if __name__ == '__main__':  # вызываем главную функцию
    main()